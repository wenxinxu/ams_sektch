import numpy as np
from collections import Counter

# The data stream will be in range [0, RANGE)
RANGE = 100
# Size of data stream
SIZE_STREAM = 10000
LAMBDA = 0.1
EPSILON = 0.01

PRIMER_init = 5000000

# TODO: online update
# TODO: timer

class PrimeGetter:
    def __init__(self):
        self.cache = {}

    @staticmethod
    def is_prime(n):
        """
            Checks whether n is prime.
        :param n:   Value to check primality.
        :type n:    int
        :return:    False  if n is composite, otherwise
                    True   (probably prime).
        :rtype:     bool
        Notes
            May return True even though n is composite.
            Probability of such event is not greater than 1 / n**2.
        Time complexity
            O(log(n)**3)
        References
            https://en.wikipedia.org/wiki/Millerâ€“Rabin_primality_test
        """

        if n == 2 or n == 3:
            return True
        elif n == 1 or n % 2 == 0:
            return False

        d = n - 1
        r = 0
        while d % 2 == 0:  # n - 1 = d * 2**r, d - odd
            r += 1
            d >>= 1

        for i in range(r):
            a = np.randint(2, n)

            x = pow(a, d, n)  # x = (a**d) % n

            if x == 1 or x == n - 1:
                continue

            stop = False
            j = 0
            while j < r - 1 and not stop:
                x = pow(x, 2, n)

                if x == 1:
                    return False
                if x == n - 1:
                    stop = True

                j += 1

            if not stop:
                return False

        return True

    def get_next_prime(self, n):
        """
            Finds smallest prime greater than n.
        :param n:   Lower bound of value of prime.
        :type n:    int
        :return:    Prime p >= n.
        :rtype:     int
        Time complexity
            O(log(n)**4)
        """

        if n in self.cache:
            return self.cache[n]

        p = n + 1
        if p % 2 == 0:
            p += 1

        while not self.is_prime(p):
            p += 2

        self.cache[n] = p
        return p



def k_independent_function(k, m=2, n=500000):
    '''
    Returns a k-independent hashing function h
    :param k: int
    :param m: number of buckets
    :return: h -> h(x) = {-1, 1}
    '''
    p = np.power(2, 31) - 1
    params = np.random.randint(low=1, high=p, size=k)

    def h(x):
        res = 0
        pow_x = 1
        for i in range(k):
            res = (res + pow_x * params[i]) % p
            pow_x = (pow_x * x) % p
        return (res % 2) * 2 - 1
    return h


def k_independent_function_vectorized(k, s1, s2, r, m=2):
    '''
    Returns the s1*s2 hashing results generated by k-independent hashing
    The iteration is fine because k is typically less than 5

    :param k: int
    :param s1: dimension 1
    :param s2: dimension 2
    :param r: int RANGE. size of self.frequency vector
    :param m: number of buckets
    :return: a matrix of size (s1 * s2 * range) with values of {-1, 1}
    '''
    prime_getter = PrimeGetter()
    p_offset = PRIMER_init

    p = np.zeros((s1, s2, 1))

    for i in range(s1):
        for j in range(s2):
            p[i, j] = prime_getter.get_next_prime(p_offset)
            p_offset += 1

    params = np.round(np.random.random(size=(s1, s2, k)) * p).astype(int)

    hashing_input = range(r)

    res = np.zeros((s1, s2, r))
    pow_x = np.ones((s1, s2, r))

    for i in range(k):
        res = (res + pow_x * params[:, :, i:i+1]) % p
        pow_x = (pow_x * hashing_input) % p
    hashed = (res % 2) * 2 - 1
    print(np.unique(hashed))
    print(np.sum(hashed))

    return hashed




class AMS_offline(object):
    '''
    AMS Sketch for offline learning. We precompute the frequency vector of the data
    stream. Online update is not implemented yet.
    '''

    def __init__(self, stream, lamb, epsilon):
        '''
        Build frequency vector
        :param stream: list of non-negative integer in range(0, RANGE)
        '''
        counter = Counter(stream)
        self.frequency_vector = np.array([counter[i] for i in sorted(list(counter))])

        self.F_1 = np.sum(self.frequency_vector)
        self.s1 = int(16 / lamb / lamb)
        self.s2 = int(2 * np.log(1 / epsilon))

    def estimate_F2(self):
        '''
        Implement the improved estimation of F2 with matrix multiplication.
        Uniformly random hashing is used in place of the four-independent hashing
        This is not exactly the same as in the original paper, but is the most popular
        way for implementation nowadays
        :return: estimated F_2
        '''
        self.hashing_matrix = np.random.choice(a = [1, -1], size=(self.s1, self.s2, RANGE), replace=True)
        Z = np.matmul(self.hashing_matrix, self.frequency_vector)
        X = np.square(Z)
        Y = np.mean(X, axis=0)
        estimation = np.median(Y)

        return estimation


    def estimate_Fk(self, k):
        '''
        Implement the estimation of Fk
        :return: estimated Fk
        '''
        self.X = np.zeros((self.s1, self.s2))

        prob = self.frequency_vector / self.F_1

        for i in range(self.s1):
            for j in range(self.s2):
                idx = np.random.choice(a=RANGE, size=1, p=prob)[0]
                r = np.random.randint(low=1, high=self.frequency_vector[idx], size=1)[0]
                self.X[i][j] = self.F_1 * (r**k - (r - 1)**k)

        Y = np.mean(self.X, axis=0)
        estimation = np.median(Y)

        return estimation



    def estimate_Fk_vectorized(self, k):
        '''
        Vectorized version of F_k estimation.
        :param k: int
        :return: estimated F_k
        '''
        prob = self.frequency_vector / self.F_1
        idx = np.random.choice(a=RANGE, size=(self.s1, self.s2), p=prob)

        onehot_idx = np.eye(RANGE)[idx]
        freq = np.matmul(onehot_idx, self.frequency_vector)
        offset = np.random.random(size=(self.s1, self.s2))
        r = np.round((freq - 1) * offset) + 1


        X = (np.power(r, k) - np.power(r-1, k)) * self.F_1
        Y = np.mean(X, axis=0)
        estimation = np.median(Y)
        return estimation




